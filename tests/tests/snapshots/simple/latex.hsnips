global
function findMatchingBracket(params) {
	return params.backward ? findMatchingBracketBackward(params) : findMatchingBracketForward(params);
}
function findMatchingBracketForward(params) {
	const { text, brackets: [open, close] } = params;
	let { start, end } = {
		start: 0,
		end: text.length - 1,
		...params
	};
	if (start < 0) start += text.length;
	if (end < 0) end += text.length;
	let i = start;
	let count = 0;
	while (i + open.length - 1 <= end && i + close.length - 1 <= end) {
		const maybeOpen = text.slice(i, i + open.length);
		if (maybeOpen === open) {
			count++;
			i += open.length;
			continue;
		}
		if ((open.length === close.length ? maybeOpen : text.slice(i, i + close.length)) === close) {
			count--;
			if (count === 0) return i;
			i += close.length;
			continue;
		}
		i++;
	}
	return -1;
}
function findMatchingBracketBackward(params) {
	const { text, brackets: [open, close] } = params;
	let { start, end } = {
		start: text.length - 1,
		end: 0,
		...params
	};
	if (start < 0) start += text.length;
	if (end < 0) end += text.length;
	let i = start + 1;
	let count = 0;
	while (i - open.length >= end && i - close.length >= end) {
		const maybeClose = text.slice(i - close.length, i);
		if (maybeClose === close) {
			count++;
			i -= close.length;
			continue;
		}
		if ((open.length === close.length ? maybeClose : text.slice(i - open.length, i)) === open) {
			count--;
			i -= open.length;
			if (count === 0) return i;
			continue;
		}
		i--;
	}
	return -1;
}
const brackets = [
	["(", ")"],
	["[", "]"],
	["{", "}"]
];
const openBracketToPair = new Map(brackets.map(([open, close]) => [open, [open, close]]));
const closeBracketToPair = new Map(brackets.map(([open, close]) => [close, [open, close]]));

/**
* @param text Preceding text
*/
function autoFraction(text) {
	let i = text.length - 1;
	for (; i >= 0; i--) {
		const char = text[i];
		if ([
			")",
			"]",
			"}"
		].includes(char)) {
			const openPos = findMatchingBracket({
				text,
				brackets: closeBracketToPair.get(char),
				backward: true,
				start: i
			});
			if (openPos !== -1) {
				i = openPos;
				continue;
			}
		}
		if ([
			"(",
			"[",
			"{"
		].includes(char)) break;
	}
	const from = i + 1;
	return text.slice(0, from) + "\\frac{" + text.slice(from) + "}";
}

/**
* "Smart" inline math. See https://castel.dev/post/lecture-notes-1/#inline-and-display-math
*/
function inlineMathSuffix(followingText) {
	return followingText && [
		",",
		".",
		"?",
		"-",
		" "
	].some((char) => followingText.startsWith(char)) ? "" : " ";
}

function math(context) {
	return context.scopes.some((scope) => !scope.startsWith("comment.line") && scope.startsWith("meta.math"));
}
endglobal

context !math(context)
snippet mk wA
$${1}$``
rv = inlineMathSuffix(t[1][0]);
``$2
endsnippet

context math(context)
snippet ali bA
\begin{aligned}
$1
\end{aligned}
endsnippet

context math(context)
snippet rm iA
\mathrm{$1}
endsnippet

context math(context)
snippet cal iA
\mathcal{$1}
endsnippet

context math(context)
snippet bf iA
\mathbf{$1}
endsnippet

context math(context)
snippet bb iA
\mathbb{$1}
endsnippet

context math(context)
snippet text iA
\text{$1}
endsnippet

context math(context)
snippet fd iA
_{$1}
endsnippet

context math(context)
snippet rd iA
^{$1}
endsnippet

context math(context)
snippet `(?<!\\)(alpha|beta|gamma|Gamma|delta|Delta|epsilon|varepsilon|zeta|eta|theta|vartheta|Theta|iota|kappa|lambda|Lambda|mu|nu|xi|omicron|pi|rho|varrho|sigma|Sigma|tau|upsilon|Upsilon|phi|varphi|Phi|chi|psi|omega|Omega)` "Greek characters" iA
\``rv = m[1]``
endsnippet

context math(context)
snippet `(?<!\\)(max|min|argmax|argmin|parallel|perp|partial|nabla|hbar|ell|infty|oplus|ominus|otimes|oslash|square|star|dagger|vee|wedge|subseteq|subset|supseteq|supset|emptyset|exists|nexists|forall|implies|impliedby|iff|setminus|neg|lor|land|bigcup|bigcap|cdot|times|simeq|approx|leq|geq|neq|gg|ll|equiv|sim|propto|rightarrow|leftarrow|Rightarrow|Leftarrow|leftrightarrow|to|mapsto|cap|cup|in|sum|prod|exp|ln|log|det|dots|vdots|ddots|pm|mp|int|iint|iiint|oint)` "Symbols" iA
\``rv = m[1]``
endsnippet

# context math(context)
# snippet `(.?)(pp|mm)` "plus" A
# ``
# const symbol = {
#     pp: '+',
#     mm: '-',
# }[m[2]];
# rv = m[1] === ' ' ? ` ${symbol} ` : m[1] === '$' ? `$${symbol}` : m[1] + ` ${symbol} `;
# ``
# endsnippet

context math(context)
snippet ` //` "fraction" iA
\frac{$1}{$2}$0
endsnippet

context math(context)
snippet `([^ /]+)/` "fraction" iA
``
rv = autoFraction(m[1]);
``{$1}$0
endsnippet


context !math(context)
snippet dm "display math" A
\begin{equation}
$1
\end{equation}
endsnippet
